// Do NOT edit this file!!! Make a copy of it and edit the copy to produce your own configuration file.
// MISRA C-2012 Rules

// This configuration file enables all rules in the MISRA C 2012 standard, including Amendment 1.

// You can disable the above rules (except mandatory rules) by adding "deviation"s and "reason"s in "deviations" field.
// Mandatory rules: 9.1, 12.5, 13.6, 17.3, 17.4, 17.6, 19.1, 21.13, 21.17, 21.18, 21.19, 21.20, 22.2, 22.4, 22.5, 22.6.

{
version : "2.0",
standard : "c2012",
title: "Coverity Level 7 Compliance",
deviations : [
    { deviation: "Directive 1.1",  reason: "Any implementation-defined behaviour on which the output of the program depends shall be documented and understood " },
    { deviation: "Directive 4.1",  reason: "Run-time failures shall be minimized" },
    { deviation: "Directive 4.9",  reason: "A function should be used in preference to a function-like macro where they are interchangeable" },
    { deviation: "Rule 1.1",       reason: "The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation's translation limits" },
    { deviation: "Rule 1.3",       reason: "There shall be no occurrence of undefined or critical unspecified behavior" },
    { deviation: "Rule 2.1",       reason: "A project shall not contain unreachable code" },
    { deviation: "Rule 2.2",       reason: "There shall be no dead code" },
    { deviation: "Rule 2.5",       reason: "There shall be no unused code" },
    { deviation: "Rule 5.6",       reason: "A typedef name shall be a unique identifier" },
    { deviation: "Rule 7.2",       reason: "A u or U shall be applied to all integer constants that are represented in an unsigned type" },
    { deviation: "Rule 7.4",       reason: "A string literal shall not be assigned to an object unless the object's type is pointer to const-qualified char" },
    { deviation: "Rule 8.2",       reason: "Function types shall be in prototype form with named parameters" },
    { deviation: "Rule 8.3",       reason: "All declarations of an object or function shall use the same names and type qualifiers" },
    { deviation: "Rule 8.4",       reason: "A compatible declaration shall be visible when an object or function with external linkage is defined " },
    { deviation: "Rule 8.5",       reason: "An external object or function shall be declared once in one and only one file" },
    { deviation: "Rule 8.6",       reason: "An identifier with external linkage shall have exactly one external definition" },
    { deviation: "Rule 9.2",       reason: "The initializer for an aggregate or union shall be enclosed in braces" },
    { deviation: "Rule 9.3",       reason: "Array shall not be partially initialized" },
    { deviation: "Rule 10.1",       reason: "Operands shall not be of an inappropriate essential type" },
    { deviation: "Rule 10.2",       reason: "Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" },
    { deviation: "Rule 10.3",       reason: "The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category" },
    { deviation: "Rule 10.4",       reason: "Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" },
    { deviation: "Rule 10.6",       reason: "The value of a composite expression shall not be assigned to an object with wider essential type" },
    { deviation: "Rule 10.7",       reason: "If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" },
    { deviation: "Rule 10.8",       reason: "The value of a composite expression shall not be cast to a different essential type category of a wider essential type" },
    { deviation: "Rule 11.1",       reason: "Conversions shall not be performed between a pointer to a function and any other type" },
    { deviation: "Rule 11.3",       reason: "A cast shall not be performed between a pointer to object type and a pointer to a different object type" },
    { deviation: "Rule 11.8",       reason: "A cast shall not remove any const or volatile qualification from the type pointed to by a pointer" },
    { deviation: "Rule 11.9",       reason: "The macro NULL shall be the only permitted form of integer null pointer constant" },
    { deviation: "Rule 12.2",       reason: "The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand" },
    { deviation: "Rule 13.5",       reason: "The right hand operand of a logical && or || operator shall not contain persistent side effects" },
    { deviation: "Rule 14.2",       reason: "A for loop shall be well-formed" },
    { deviation: "Rule 14.3",       reason: "Controlling expressions shall not be invariant" },
    { deviation: "Rule 14.4",       reason: "The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type" },
    { deviation: "Rule 15.6",       reason: "The body of an iteration-statement or a selection-statement shall be a compound-statement" },
    { deviation: "Rule 15.7",       reason: "All if...else if constructs shall be terminated with an else statement" },
    { deviation: "Rule 16.3",       reason: "An unconditional break statement shall terminate every switch-clause" },
    { deviation: "Rule 16.4",       reason: "Every switch statement shall have a default label" },
    { deviation: "Rule 17.1",       reason: "The features of <stdarg.h> shall not be used" },
    { deviation: "Rule 17.2",       reason: "Functions shall not call themselves, either directly or indirectly" },
    { deviation: "Rule 17.7",       reason: "The value returned by a function having non-void return type shall be used" },
    { deviation: "Rule 20.7",       reason: "Expression resulting from the expansion of macro parameters shall be enclosed in parentheses" },
    { deviation: "Rule 20.9",       reason: "All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation" },
    { deviation: "Rule 20.13",       reason: "A line whose first token is # shall be a valid preprocessing directive" },
    { deviation: "Rule 21.3",       reason: "The memory allocation and deallocation functions of <stdlib.h> shall not be used" },
    { deviation: "Rule 1.2",       reason: "Language extensions should not be used" },
    { deviation: "Rule 2.6",       reason: "A function should not contain unused label declarations" },
    { deviation: "Rule 2.7",       reason: "There should be no unused parameters in functions" },
    { deviation: "Rule 8.9",       reason: "An object should be defined at block scope if its identifier only appears in a single function" },
    { deviation: "Rule 8.11",       reason: "When an array with external linkage is declared, its size should be explicitly specified" },
    { deviation: "Rule 8.13",       reason: "A pointer should point to a const-qualified type whenever possible" },
    { deviation: "Rule 10.5",       reason: "The value of an expression should not be cast to an inappropriate essential type" },
    { deviation: "Rule 11.4",       reason: "A conversion should not be performed between a pointer to object and an integer type" },
    { deviation: "Rule 11.5",       reason: "A conversion should not be performed from pointer to void into pointer to object" },
    { deviation: "Rule 12.1",       reason: "The precedence of operators within expressions should be made explicit" },
    { deviation: "Rule 12.3",       reason: "The comma operator should not be used" },
    { deviation: "Rule 13.3",       reason: "A full expression containing an increment(++) or decrement(--) operator should have no other potential side effects other than that caused by the increment or decrement operator" },
    { deviation: "Rule 13.4",       reason: "The result of an assignment operator should not be used" },
    { deviation: "Rule 15.1",       reason: "The goto statement should not be used" },
    { deviation: "Rule 15.4",       reason: "There should be no more than one break or goto statement used to terminate any iteration statement" },
    { deviation: "Rule 15.5",       reason: "A function should have a single point of exit at the end" },
    { deviation: "Rule 18.4",       reason: "The +, -, += and -= operators should not be applied to an expression of pointer type" },
    { deviation: "Rule 19.2",       reason: "The union keyword should not be used" },
    { deviation: "Rule 20.5",       reason: "#undef should not be used" },
    { deviation: "Rule 20.10",       reason: "The # and ## preprocessor operators should not be used" },
    { deviation: "Rule 17.8",       reason: "A function parameter should not be modified"},
    ]
}

